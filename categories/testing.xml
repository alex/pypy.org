<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PyPy (Posts about testing)</title><link>https://www.pypy.org/</link><description></description><atom:link href="https://www.pypy.org/categories/testing.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents Â© 2024 &lt;a href="mailto:pypy-dev@pypy.org"&gt;The PyPy Team&lt;/a&gt; </copyright><lastBuildDate>Tue, 26 Mar 2024 21:44:34 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Finding JIT Optimizer Bugs using SMT Solvers and Fuzzing</title><link>https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html</link><dc:creator>Carl Friedrich Bolz-Tereick</dc:creator><description>&lt;p&gt;In this blog post I want to describe a recent bug finding technique that I've
added to the PyPy JIT testing infrastructure. This technique uses the Z3
theorem prover to find bugs in the optimizer of PyPy's JIT, in particular its
integer operation optimizations. The approach is
based on things I have learned from &lt;a class="reference external" href="https://www.cs.utah.edu/~regehr/"&gt;John Regehr's&lt;/a&gt; &lt;a class="reference external" href="https://blog.regehr.org/"&gt;blog&lt;/a&gt; (&lt;a class="reference external" href="https://blog.regehr.org/archives/1122"&gt;this post&lt;/a&gt; is a
good first one to read), &lt;a class="reference external" href="https://twitter.com/johnregehr/"&gt;Twitter&lt;/a&gt;, and on
his (et al) paper &lt;a class="reference external" href="https://www.cs.utah.edu/~regehr/alive2-pldi21.pdf"&gt;Alive2: Bounded Translation Validation for LLVM&lt;/a&gt;. The work
was triggered by a recent miscompilation bug my current bachelor student Nico
Rittinghaus found.&lt;/p&gt;
&lt;section id="background-python-integers-in-the-pypy-jit"&gt;
&lt;h2&gt;Background: Python Integers in the PyPy JIT&lt;/h2&gt;
&lt;p&gt;The optimizer of PyPy's JITs operates on traces, which are linear sequences of
instructions with guards. The instructions in the traces operate on different
machine-level data types, machine integers, doubles, pointers, bools, etc. In
this post we'll be mostly concerned with machine integers.&lt;/p&gt;
&lt;p&gt;To given some wider context I'll explain a bit how Python ints in the user code
relate to the types that are used in traces when the PyPy Python implementation
is used.
When PyPy turns a regular Python 3 function into a trace, there is a lot of work
happening in the JIT frontend to try to observe and infer the types that the
Python function concretely uses at runtime. The traces are generated under these
typing assumptions. Therefore, code that uses &lt;code class="docutils literal"&gt;ints&lt;/code&gt; in the Python code can
typically be translated into traces that operate on machine integers. In order
to make sure that the Python integer semantics are upheld, many of the
operations in the traces need to check that the integer results of some
operations still fit into a machine integer. If that is not the case (a rare
situation for most programs), the trace is left via a guard, execution falls
back to the interpreter, and there a big integer representation is chosen for
the too big value (the big integer representation is done via a pointer and
some storage on the heap).&lt;/p&gt;
&lt;p&gt;All of this machinery is not going to be too relevant for the rest of the
post. For the post it's important to know that trace instructions operate on
machine integers and other low-level types, and some of the operations can
optionally check whether the
results still fit into a machine integer. These trace operations are improved by
the optimizer, which tries to transform the trace into one that behaves the
same, but is less costly to execute.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="background-bounds-analysis-in-pypy-s-jit"&gt;
&lt;h2&gt;Background: Bounds Analysis in PyPy's JIT&lt;/h2&gt;
&lt;p&gt;The optimizer of PyPy's JIT has an analysis based on &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Abstract_interpretation"&gt;abstract interpretation&lt;/a&gt;
that tries to find out whether the integer values stored in a variable are
actually not using the full 64 bit (or 32 bit) range, but instead fit into some
smaller range. This means that for every integer variable &lt;code class="docutils literal"&gt;x&lt;/code&gt; in a trace, the
JIT compiler tracks upper and lower bounds of the runtime value of that
variable: a range &lt;code class="docutils literal"&gt;[a, b]&lt;/code&gt; such that for every concrete runtime value &lt;code class="docutils literal"&gt;v&lt;/code&gt;
that gets stored in variable &lt;code class="docutils literal"&gt;x&lt;/code&gt;, &lt;code class="docutils literal"&gt;a &amp;lt;= v &amp;lt;= b&lt;/code&gt; must be true.
&lt;code class="docutils literal"&gt;a&lt;/code&gt; and &lt;code class="docutils literal"&gt;b&lt;/code&gt; start out
as the most general &lt;code class="docutils literal"&gt;MININT&lt;/code&gt; and &lt;code class="docutils literal"&gt;MAXINT&lt;/code&gt;, but sometimes there is extra
information that makes it possible to improve these known bounds, and that is
often useful to optimize the code.&lt;/p&gt;
&lt;p&gt;A typical example is that the JIT knows that the length of a string is
non-negative, so for this kind of code: &lt;code class="docutils literal"&gt;x = len(s)&lt;/code&gt; where &lt;code class="docutils literal"&gt;s&lt;/code&gt; is a string,
&lt;code class="docutils literal"&gt;x&lt;/code&gt; gets a range &lt;code class="docutils literal"&gt;[0, MAXINT]&lt;/code&gt; assigned. With this information we could for
example remove a check &lt;code class="docutils literal"&gt;x + 10 &amp;lt; 0&lt;/code&gt; completely, because it can never be true.&lt;/p&gt;
&lt;p&gt;The bounds information is useful for optimization, but the analysis of the
bounds is also a source of bugs in the JIT, because the reasoning is often
subtle and easy to get wrong in corner cases. We already use a number of testing
techniques to try to make sure that it is correct. A simple one is
&lt;a class="reference external" href="https://hypothesis.works/articles/what-is-property-based-testing/"&gt;property-based testing&lt;/a&gt; using &lt;a class="reference external" href="https://github.com/HypothesisWorks/hypothesis"&gt;Hypothesis&lt;/a&gt; on the operations on bounds. Even
though Hypothesis is fantastic, it unfortunately does not catch
absolutely all the bugs even if we'd like it too, as we'll see in the next
section.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="motivation-a-jit-miscompilation"&gt;
&lt;h2&gt;Motivation: A JIT Miscompilation&lt;/h2&gt;
&lt;p&gt;I am currently supervising a Bachelor thesis by Nico Rittinghaus, who is
extending the integer analysis in the JIT. He'll probably write a separate blog
post about that soon. In the process of his work, the current bounds analysis
code got a lot of scrutiny, and we found out that one of the unit tests of the
bounds analysis was actually incorrect, and the example code in that unit test
was optimized incorrectly. This case of incorrect optimization is not a big deal
for regular Python code, because it involved a "wrapping integer addition
operation", i.e. one where overflowing results just wrap around to negative
values. All the additions and other arithmetic operations that the PyPy Python
frontend generates actually have
overflow checks (to be able to switch to a big integer representation if
needed).
However, it's still possible to trigger the problem with the
&lt;code class="docutils literal"&gt;__pypy__.intop.int_add&lt;/code&gt; API which is a function that exposes wraparound
arithmetic on Python ints.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/issues/3832"&gt;Here's the miscompilation&lt;/a&gt;. The JIT optimizes the following function:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_0e708e560ce74dbfb31879056c8219a2-1" name="rest_code_0e708e560ce74dbfb31879056c8219a2-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_0e708e560ce74dbfb31879056c8219a2-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;__pypy__&lt;/span&gt;
&lt;a id="rest_code_0e708e560ce74dbfb31879056c8219a2-2" name="rest_code_0e708e560ce74dbfb31879056c8219a2-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_0e708e560ce74dbfb31879056c8219a2-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_0e708e560ce74dbfb31879056c8219a2-3" name="rest_code_0e708e560ce74dbfb31879056c8219a2-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_0e708e560ce74dbfb31879056c8219a2-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_0e708e560ce74dbfb31879056c8219a2-4" name="rest_code_0e708e560ce74dbfb31879056c8219a2-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_0e708e560ce74dbfb31879056c8219a2-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__pypy__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;intop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_0e708e560ce74dbfb31879056c8219a2-5" name="rest_code_0e708e560ce74dbfb31879056c8219a2-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_0e708e560ce74dbfb31879056c8219a2-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_0e708e560ce74dbfb31879056c8219a2-6" name="rest_code_0e708e560ce74dbfb31879056c8219a2-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_0e708e560ce74dbfb31879056c8219a2-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_0e708e560ce74dbfb31879056c8219a2-7" name="rest_code_0e708e560ce74dbfb31879056c8219a2-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_0e708e560ce74dbfb31879056c8219a2-7"&gt;&lt;/a&gt;            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;a id="rest_code_0e708e560ce74dbfb31879056c8219a2-8" name="rest_code_0e708e560ce74dbfb31879056c8219a2-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_0e708e560ce74dbfb31879056c8219a2-8"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;a id="rest_code_0e708e560ce74dbfb31879056c8219a2-9" name="rest_code_0e708e560ce74dbfb31879056c8219a2-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_0e708e560ce74dbfb31879056c8219a2-9"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Into the following code:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_1feddbcf0d8649f2a319a1c2002654dc-1" name="rest_code_1feddbcf0d8649f2a319a1c2002654dc-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_1feddbcf0d8649f2a319a1c2002654dc-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;__pypy__&lt;/span&gt;
&lt;a id="rest_code_1feddbcf0d8649f2a319a1c2002654dc-2" name="rest_code_1feddbcf0d8649f2a319a1c2002654dc-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_1feddbcf0d8649f2a319a1c2002654dc-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_1feddbcf0d8649f2a319a1c2002654dc-3" name="rest_code_1feddbcf0d8649f2a319a1c2002654dc-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_1feddbcf0d8649f2a319a1c2002654dc-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_1feddbcf0d8649f2a319a1c2002654dc-4" name="rest_code_1feddbcf0d8649f2a319a1c2002654dc-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_1feddbcf0d8649f2a319a1c2002654dc-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__pypy__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;intop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_1feddbcf0d8649f2a319a1c2002654dc-5" name="rest_code_1feddbcf0d8649f2a319a1c2002654dc-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_1feddbcf0d8649f2a319a1c2002654dc-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_1feddbcf0d8649f2a319a1c2002654dc-6" name="rest_code_1feddbcf0d8649f2a319a1c2002654dc-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_1feddbcf0d8649f2a319a1c2002654dc-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;a id="rest_code_1feddbcf0d8649f2a319a1c2002654dc-7" name="rest_code_1feddbcf0d8649f2a319a1c2002654dc-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_1feddbcf0d8649f2a319a1c2002654dc-7"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically the faulty reasoning of the JIT looks like this: if &lt;code class="docutils literal"&gt;int_add(x, 10) &amp;lt; 15&lt;/code&gt;
then it must follow that &lt;code class="docutils literal"&gt;x &amp;lt; 5&lt;/code&gt;, which is stronger than &lt;code class="docutils literal"&gt;x &amp;lt; 6&lt;/code&gt;, so the
second &lt;code class="docutils literal"&gt;if&lt;/code&gt; is always true. This sounds good, but is actually wrong
if the addition &lt;code class="docutils literal"&gt;+ 10&lt;/code&gt; wrapped around. So if &lt;code class="docutils literal"&gt;x == MAXINT&lt;/code&gt;, then
&lt;code class="docutils literal"&gt;int_add(x, 10) == MININT + 9 &amp;lt; 15&lt;/code&gt;. But &lt;code class="docutils literal"&gt;MAXINT &amp;lt; 5&lt;/code&gt; is not
correct.&lt;/p&gt;
&lt;p&gt;Note how the same reasoning with overflow-checking addition is correct! If &lt;code class="docutils literal"&gt;x +
10 &amp;lt; 15&lt;/code&gt; and the &lt;code class="docutils literal"&gt;+&lt;/code&gt; didn't overflow, then indeed &lt;code class="docutils literal"&gt;x &amp;lt; 6&lt;/code&gt;. And if your
mind bends starting to think about all this, you understand some of the
difficulty of getting the JIT correct in this area.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="how-could-we-have-avoided-this-bug"&gt;
&lt;h2&gt;How could we have avoided this bug?&lt;/h2&gt;
&lt;p&gt;One &lt;a class="reference external" href="https://twitter.com/cfbolz/status/1482649144099586051"&gt;exercise I try to do after finding bugs&lt;/a&gt; is to reflect on ways that the
bug could have been avoided. I think this is particularly important in the JIT,
where bugs are potentially really annoying to find and can cause very strange
behaviour in basically arbitrary Python code.&lt;/p&gt;
&lt;p&gt;It's easy to always answer this question with "try to think more carefully
when working", but that approach cannot be relied on in complicated situations,
because humans don't concentrate perfectly for long stretches of time.&lt;/p&gt;
&lt;p&gt;A situation-specific problem I identified was the bad design of the range analysis API.
A range is not just represented by two numbers, instead it's two numbers
and two bools that are supposed to represent that some operation did or did not
underflow/overflow. The meaning of these bools was quite hard to grasp and easy
to get wrong, so probably they should never have been introduced in the first
place (and my bugfix indeed removed them).&lt;/p&gt;
&lt;p&gt;But in the rest of this blog post I want to talk about another, systematic
approach that can be applied to the problem of mis-optimizations of integer
operations, and that is done by applying an SMT solver to the problem.&lt;/p&gt;
&lt;p&gt;An SMT solver (&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories"&gt;Satisfyability Modulo Theories&lt;/a&gt;) is a tool that can be used to
find out whether mathematical formulas are "satisfiable", i.e. whether
some chosen set of inputs exists that will make the formulas evaluate to true. SMT solvers are
commonly used in a wide range of CS applications including program correctness
proofs, program synthesis, etc. The most widely known one is probably &lt;a class="reference external" href="https://github.com/Z3Prover"&gt;Z3&lt;/a&gt; by
Microsoft Research which has the nice advantage of coming with an easy-to-use
Python binding.&lt;/p&gt;
&lt;p&gt;Going into this I basically knew next to nothing about SMT solvers (despite
having been embedded in a formal methods research group for years!) so it was an
interesting new world to learn about.&lt;/p&gt;
&lt;p&gt;As briefly mentioned in the introduction, the approach I took followed a similar
(but &lt;em&gt;much&lt;/em&gt; more properly executed) one applied to LLVM operations, called
&lt;a class="reference external" href="https://github.com/AliveToolkit/alive2/"&gt;Alive2&lt;/a&gt;. Krister Waldfridsson has done &lt;a class="reference external" href="https://kristerw.github.io/2022/09/13/translation-validation/"&gt;similar work for GCC recently&lt;/a&gt;,
described on his blog.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="z3-proof-of-concept"&gt;
&lt;h2&gt;Z3 Proof of Concept&lt;/h2&gt;
&lt;p&gt;The first thing I did was to try to get Z3 find the above bug, by encoding the
input program into an SMT formula by hand and trying to get Z3 to prove the condition
that the JIT thinks is always true. The Z3 code for this looks as follows:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-1" name="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;z3&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Implies&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prove&lt;/span&gt;
&lt;a id="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-2" name="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-2"&gt;&lt;/a&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'x'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-3" name="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-3"&gt;&lt;/a&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;a id="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-4" name="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-4"&gt;&lt;/a&gt;&lt;span class="n"&gt;cond1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;a id="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-5" name="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-5"&gt;&lt;/a&gt;&lt;span class="n"&gt;cond2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;a id="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-6" name="rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_a70f80dfe1e44440bd1ad85be0fb4ce2-6"&gt;&lt;/a&gt;&lt;span class="n"&gt;prove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Implies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cond1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cond2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code class="docutils literal"&gt;x&lt;/code&gt; is defined to be a bit vector variable of width 64, which is a
datatype that can be used to represent bounded machine integers. Addition on
bit vectors performs wraparound arithmetic, like the &lt;code class="docutils literal"&gt;__pypy__.intop.int_add&lt;/code&gt;
call in the original code. The JIT optimized the second condition away, so
essentially it was convinced that the first condition implies the second one.
The above snippet tries to get Z3 to confirm this.&lt;/p&gt;
&lt;p&gt;When run, the above program prints:&lt;/p&gt;
&lt;pre class="literal-block"&gt;counterexample
[x = 9223372036854775803]&lt;/pre&gt;
&lt;p&gt;Which shows the bug. As a small side-note, I thought it was cool that the
process of "proving" something in Z3 basically means trying to find an example
for the negation of the formula. If no counterexample can be found for the
negation, the original formula is true. If the original formula turns out to be
false (like here) we get a nice example that shows the problem to go with it.&lt;/p&gt;
&lt;p&gt;It's not realistic to hand-translate all the hundreds of
unit-tests into Z3 formulas and then ask Z3 to prove the optimizations. Instead,
we want to have a program that does this for us.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="smt-checking-of-the-jit-optimizer"&gt;
&lt;h2&gt;SMT Checking of the JIT Optimizer&lt;/h2&gt;
&lt;p&gt;What we want from this program is the following: given an unoptimized trace and
its optimized version, we want to use Z3 to check whether the optimized trace
behaves identically to the unoptimized one. One question is what "behaves
identically" means. What we care about is the outputs of the trace being the
same values, no matter how they are computed. Also, for every guard we want to
make sure that it fails in identical ways in the optimized and unoptimized
versions. A guard is only allowed to be optimized away if it can never fail.
The code that comes after a guard can assume that the guard has not failed,
because otherwise execution would have left the trace. All of this should be
true regardless for the values of the input variables of the trace.&lt;/p&gt;
&lt;p&gt;So in order to check that the two traces are behaving identically, we do the
following:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;We create Z3 variables for every input variable. We use the same input
variables both for the unoptimized as well as the optimized trace.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We align the two traces at the corresponding guards. Thankfully the optimizer
keeps track of which optimized guard corresponds to which unoptimized input
guard.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All the operations before a guard are translated into Z3 formulas, for both
versions of the trace.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For two corresponding guards, we ask Z3 to prove that the guard conditions are
identical.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For a guard that was optimized away we ask Z3 to prove that the condition is
always true.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;After a guard, we tell Z3 that from now on it can assume that the guard
condition is true.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We repeat this, guard for guard, until we reach the end of the trace. There,
we ask Z3 to prove that the output variables in the unoptimized trace and the
optimized trace are identical (every trace can return one or many values).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I implemented this, it's &lt;a class="reference external" href="https://foss.heptapod.net/pypy/pypy/-/blob/branch/default/rpython/jit/metainterp/optimizeopt/test/test_z3checktests.py"&gt;not a lot of code&lt;/a&gt;, basically a couple of hundred lines
of (somewhat hacky) Python code. So far I only support integer
operations. Here are some parts of the code to give you a flavor of what this
looks like.&lt;/p&gt;
&lt;p&gt;This is the code that translates operations into Z3 formulas:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_994e267f40c543e6939702a089524225-1" name="rest_code_994e267f40c543e6939702a089524225-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add_to_solver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-2" name="rest_code_994e267f40c543e6939702a089524225-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-2"&gt;&lt;/a&gt;    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-3" name="rest_code_994e267f40c543e6939702a089524225-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-3"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s1"&gt;'v'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# is it an operation with a result&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-4" name="rest_code_994e267f40c543e6939702a089524225-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-4"&gt;&lt;/a&gt;            &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;newvar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-5" name="rest_code_994e267f40c543e6939702a089524225-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-5"&gt;&lt;/a&gt;        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# or does it return void&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-6" name="rest_code_994e267f40c543e6939702a089524225-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-6"&gt;&lt;/a&gt;            &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-7" name="rest_code_994e267f40c543e6939702a089524225-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-7"&gt;&lt;/a&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-8" name="rest_code_994e267f40c543e6939702a089524225-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-8"&gt;&lt;/a&gt;       &lt;span class="c1"&gt;# ...&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-9" name="rest_code_994e267f40c543e6939702a089524225-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-9"&gt;&lt;/a&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-10" name="rest_code_994e267f40c543e6939702a089524225-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-10"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# convert arguments&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-11" name="rest_code_994e267f40c543e6939702a089524225-11" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-11"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;numargs&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-12" name="rest_code_994e267f40c543e6939702a089524225-12" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-12"&gt;&lt;/a&gt;            &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-13" name="rest_code_994e267f40c543e6939702a089524225-13" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-13"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;numargs&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-14" name="rest_code_994e267f40c543e6939702a089524225-14" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-14"&gt;&lt;/a&gt;            &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-15" name="rest_code_994e267f40c543e6939702a089524225-15" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-15"&gt;&lt;/a&gt;            &lt;span class="n"&gt;arg1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-16" name="rest_code_994e267f40c543e6939702a089524225-16" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-16"&gt;&lt;/a&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-17" name="rest_code_994e267f40c543e6939702a089524225-17" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-17"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# compute results&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-18" name="rest_code_994e267f40c543e6939702a089524225-18" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-18"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_add"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-19" name="rest_code_994e267f40c543e6939702a089524225-19" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-19"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-20" name="rest_code_994e267f40c543e6939702a089524225-20" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-20"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_sub"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-21" name="rest_code_994e267f40c543e6939702a089524225-21" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-21"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-22" name="rest_code_994e267f40c543e6939702a089524225-22" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-22"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_mul"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-23" name="rest_code_994e267f40c543e6939702a089524225-23" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-23"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-24" name="rest_code_994e267f40c543e6939702a089524225-24" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-24"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_and"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-25" name="rest_code_994e267f40c543e6939702a089524225-25" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-25"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-26" name="rest_code_994e267f40c543e6939702a089524225-26" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-26"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_or"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-27" name="rest_code_994e267f40c543e6939702a089524225-27" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-27"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-28" name="rest_code_994e267f40c543e6939702a089524225-28" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-28"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_xor"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-29" name="rest_code_994e267f40c543e6939702a089524225-29" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-29"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-30" name="rest_code_994e267f40c543e6939702a089524225-30" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-30"&gt;&lt;/a&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-31" name="rest_code_994e267f40c543e6939702a089524225-31" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-31"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ...  more operations, some shown below&lt;/span&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-32" name="rest_code_994e267f40c543e6939702a089524225-32" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-32"&gt;&lt;/a&gt;
&lt;a id="rest_code_994e267f40c543e6939702a089524225-33" name="rest_code_994e267f40c543e6939702a089524225-33" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_994e267f40c543e6939702a089524225-33"&gt;&lt;/a&gt;        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;solver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;New Z3 variables are defined by the helper function &lt;code class="docutils literal"&gt;newvar&lt;/code&gt;, which adds the
operation to a dictionary &lt;code class="docutils literal"&gt;box_to_z3&lt;/code&gt; mapping boxes (=variables) to Z3
variables. Due to the &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Static_single-assignment_form"&gt;SSA&lt;/a&gt; property that traces have, a variable must be defined
before its first use.&lt;/p&gt;
&lt;p&gt;Here's what &lt;code class="docutils literal"&gt;newvar&lt;/code&gt; looks like (&lt;code class="docutils literal"&gt;LONG_BIT&lt;/code&gt; is a constant that is either
&lt;code class="docutils literal"&gt;64&lt;/code&gt; or &lt;code class="docutils literal"&gt;32&lt;/code&gt;, depending on the target architecture):&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-1" name="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;newvar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-2" name="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-2"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# ... some logic around making the string representation&lt;/span&gt;
&lt;a id="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-3" name="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-3"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# somewhat nicer omitted&lt;/span&gt;
&lt;a id="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-4" name="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVec&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-5" name="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-5"&gt;&lt;/a&gt;    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box_to_z3&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;a id="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-6" name="rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_31f3c2bba7214bacbd5b5d28a5e4e9ef-6"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code class="docutils literal"&gt;convert&lt;/code&gt; method turns an operation argument (either a constant or a
variable) into a Z3 formula (either a constant bit vector or an already defined
Z3 variable). &lt;code class="docutils literal"&gt;convertarg&lt;/code&gt; is a helper function that takes an operation, reads
its nth argument and converts it.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_8ae3c5c413324a199ddb437b1084c334-1" name="rest_code_8ae3c5c413324a199ddb437b1084c334-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_8ae3c5c413324a199ddb437b1084c334-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;convert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_8ae3c5c413324a199ddb437b1084c334-2" name="rest_code_8ae3c5c413324a199ddb437b1084c334-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_8ae3c5c413324a199ddb437b1084c334-2"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ConstInt&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_8ae3c5c413324a199ddb437b1084c334-3" name="rest_code_8ae3c5c413324a199ddb437b1084c334-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_8ae3c5c413324a199ddb437b1084c334-3"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BitVecVal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getint&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_8ae3c5c413324a199ddb437b1084c334-4" name="rest_code_8ae3c5c413324a199ddb437b1084c334-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_8ae3c5c413324a199ddb437b1084c334-4"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;box_to_z3&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;a id="rest_code_8ae3c5c413324a199ddb437b1084c334-5" name="rest_code_8ae3c5c413324a199ddb437b1084c334-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_8ae3c5c413324a199ddb437b1084c334-5"&gt;&lt;/a&gt;
&lt;a id="rest_code_8ae3c5c413324a199ddb437b1084c334-6" name="rest_code_8ae3c5c413324a199ddb437b1084c334-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_8ae3c5c413324a199ddb437b1084c334-6"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_8ae3c5c413324a199ddb437b1084c334-7" name="rest_code_8ae3c5c413324a199ddb437b1084c334-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_8ae3c5c413324a199ddb437b1084c334-7"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;box&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The lookup of variables in &lt;code class="docutils literal"&gt;box_to_z3&lt;/code&gt; that &lt;code class="docutils literal"&gt;convert&lt;/code&gt; does cannot fail,
because the variable must have been defined before use.&lt;/p&gt;
&lt;p&gt;Comparisons return the bit vector 0 or bit vector 1, we use a helper function
&lt;code class="docutils literal"&gt;cond&lt;/code&gt; to turn the Z3 truth value of the comparison into a bit vector:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-1" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z3expr&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-2" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-2"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;If&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TRUEBV&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-3" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-3"&gt;&lt;/a&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-4" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-4"&gt;&lt;/a&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-5" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-5"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add_to_solver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-6" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-6"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ... start as above&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-7" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-7"&gt;&lt;/a&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-8" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-8"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# more cases&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-9" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-9"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_eq"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-10" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-10"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-11" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-11" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-11"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_ne"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-12" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-12" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-12"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-13" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-13" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-13"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_lt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-14" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-14" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-14"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-15" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-15" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-15"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_le"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-16" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-16" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-16"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-17" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-17" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-17"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_gt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-18" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-18" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-18"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-19" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-19" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-19"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_ge"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-20" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-20" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-20"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-21" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-21" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-21"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_is_true"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-22" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-22" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-22"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-23" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-23" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-23"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_lt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-24" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-24" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-24"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ULT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-25" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-25" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-25"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_le"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-26" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-26" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-26"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ULE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-27" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-27" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-27"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_gt"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-28" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-28" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-28"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UGT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-29" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-29" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-29"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"uint_ge"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-30" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-30" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-30"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UGE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-31" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-31" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-31"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_is_zero"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-32" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-32" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-32"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-33" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-33" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-33"&gt;&lt;/a&gt;
&lt;a id="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-34" name="rest_code_72aca77b4ad841b8aaf7458c8f2353b7-34" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_72aca77b4ad841b8aaf7458c8f2353b7-34"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ... rest as above&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So basically for every trace operation that operates on integers I had to give a
translation into Z3 formulas, which is mostly straightforward.&lt;/p&gt;
&lt;p&gt;Guard operations get converted into a Z3 boolean by their own helper function,
which looks like this:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-1" name="rest_code_62564326b02743a99d3219aa43fb57fc-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;guard_to_condition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-2" name="rest_code_62564326b02743a99d3219aa43fb57fc-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-2"&gt;&lt;/a&gt;    &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getopname&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-3" name="rest_code_62564326b02743a99d3219aa43fb57fc-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-3"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_true"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-4" name="rest_code_62564326b02743a99d3219aa43fb57fc-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-4"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;TRUEBV&lt;/span&gt;
&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-5" name="rest_code_62564326b02743a99d3219aa43fb57fc-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_false"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-6" name="rest_code_62564326b02743a99d3219aa43fb57fc-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;FALSEBV&lt;/span&gt;
&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-7" name="rest_code_62564326b02743a99d3219aa43fb57fc-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-7"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_value"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-8" name="rest_code_62564326b02743a99d3219aa43fb57fc-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-8"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;convertarg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-9" name="rest_code_62564326b02743a99d3219aa43fb57fc-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-9"&gt;&lt;/a&gt;
&lt;a id="rest_code_62564326b02743a99d3219aa43fb57fc-10" name="rest_code_62564326b02743a99d3219aa43fb57fc-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_62564326b02743a99d3219aa43fb57fc-10"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# ... some more exist, shown below&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Some operations are a bit trickier. An important example in the context of
this blog post are integer operations that check for overflow. The overflow
operations return a result, but also a boolean whether the operation overflowed
or not.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-1" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;add_to_solver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-2" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-3" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-3"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ... more cases&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-4" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-4"&gt;&lt;/a&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-5" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-5"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_add_ovf"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-6" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-6"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-7" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-7"&gt;&lt;/a&gt;            &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-8" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-8"&gt;&lt;/a&gt;            &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-9" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-9"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_sub_ovf"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-10" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-10"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-11" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-11" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-11"&gt;&lt;/a&gt;            &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-12" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-12" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-12"&gt;&lt;/a&gt;            &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-13" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-13" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-13"&gt;&lt;/a&gt;        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"int_mul_ovf"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-14" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-14" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-14"&gt;&lt;/a&gt;            &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-15" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-15" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-15"&gt;&lt;/a&gt;            &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-16" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-16" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-16"&gt;&lt;/a&gt;            &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SignExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LONG_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-17" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-17" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-17"&gt;&lt;/a&gt;
&lt;a id="rest_code_fb58ca6e77434567877bf84977d1ebd1-18" name="rest_code_fb58ca6e77434567877bf84977d1ebd1-18" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_fb58ca6e77434567877bf84977d1ebd1-18"&gt;&lt;/a&gt;        &lt;span class="c1"&gt;# ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The boolean is computed by comparing the result of the bit vector operation with
the result of converting the input bit vectors into an abstract (arbitrary
precision) integer and the result back to bit vectors. Let's go through the
addition case step by step, the other cases work analogously.&lt;/p&gt;
&lt;p&gt;The addition in the first &lt;code class="docutils literal"&gt;elif&lt;/code&gt; that computes &lt;code class="docutils literal"&gt;expr&lt;/code&gt; is an addition on bit
vectors, therefore it is performing wraparound arithmetic.
&lt;code class="docutils literal"&gt;z3.SignExt(LONG_BIT, arg0)&lt;/code&gt; sign-extends &lt;code class="docutils literal"&gt;arg0&lt;/code&gt; from a bit vector of
&lt;code class="docutils literal"&gt;LONG_BIT&lt;/code&gt; bits to an abstract, arbitrary precision integer. The addition in
the second line is therefore an addition between abstract integers, so it will
never overflow and just compute the correct result as an integer.&lt;/p&gt;
&lt;p&gt;The condition to check for overflow is now: if the results of the two different
ways to do the addition are the same, then overflow did not occur. So in order
to compute &lt;code class="docutils literal"&gt;state.no_ovf&lt;/code&gt; in the addition case the
code converts the result of the bit vector wraparound addition to
an abstract integer (using &lt;code class="docutils literal"&gt;SignExt&lt;/code&gt; again), and then compares that to the integer
result.&lt;/p&gt;
&lt;p&gt;This boolean can then be checked by the guard operations &lt;code class="docutils literal"&gt;guard_no_overflow&lt;/code&gt;
and &lt;code class="docutils literal"&gt;guard_overflow&lt;/code&gt;.&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-1" name="rest_code_54e801177b374df7b5693ebeef616d14-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-1"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;guard_to_condition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;guard&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-2" name="rest_code_54e801177b374df7b5693ebeef616d14-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-3" name="rest_code_54e801177b374df7b5693ebeef616d14-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-3"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# ... more cases&lt;/span&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-4" name="rest_code_54e801177b374df7b5693ebeef616d14-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-4"&gt;&lt;/a&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-5" name="rest_code_54e801177b374df7b5693ebeef616d14-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_no_overflow"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-6" name="rest_code_54e801177b374df7b5693ebeef616d14-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-7" name="rest_code_54e801177b374df7b5693ebeef616d14-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-7"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-8" name="rest_code_54e801177b374df7b5693ebeef616d14-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-8"&gt;&lt;/a&gt;    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;opname&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"guard_overflow"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-9" name="rest_code_54e801177b374df7b5693ebeef616d14-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-9"&gt;&lt;/a&gt;        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-10" name="rest_code_54e801177b374df7b5693ebeef616d14-10" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-10"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;z3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Not&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;no_ovf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-11" name="rest_code_54e801177b374df7b5693ebeef616d14-11" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-11"&gt;&lt;/a&gt;
&lt;a id="rest_code_54e801177b374df7b5693ebeef616d14-12" name="rest_code_54e801177b374df7b5693ebeef616d14-12" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_54e801177b374df7b5693ebeef616d14-12"&gt;&lt;/a&gt;    &lt;span class="c1"&gt;# ... more cases&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id="finding-the-bug-again"&gt;
&lt;h2&gt;Finding the Bug, Again&lt;/h2&gt;
&lt;p&gt;Let's actually make all of this more concrete by applying it to the trace of our
original bug. The input trace and the incorrectly optimized trace for that look
like this (differences highlighted):&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_f7ceebc7cb5d420da69d506ad87316d5-1" name="rest_code_f7ceebc7cb5d420da69d506ad87316d5-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f7ceebc7cb5d420da69d506ad87316d5-1"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# input                       # optimized&lt;/span&gt;
&lt;a id="rest_code_f7ceebc7cb5d420da69d506ad87316d5-2" name="rest_code_f7ceebc7cb5d420da69d506ad87316d5-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f7ceebc7cb5d420da69d506ad87316d5-2"&gt;&lt;/a&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;                          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;a id="rest_code_f7ceebc7cb5d420da69d506ad87316d5-3" name="rest_code_f7ceebc7cb5d420da69d506ad87316d5-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f7ceebc7cb5d420da69d506ad87316d5-3"&gt;&lt;/a&gt;&lt;span class="n"&gt;i1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="n"&gt;i1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_f7ceebc7cb5d420da69d506ad87316d5-4" name="rest_code_f7ceebc7cb5d420da69d506ad87316d5-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f7ceebc7cb5d420da69d506ad87316d5-4"&gt;&lt;/a&gt;&lt;span class="n"&gt;i2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;           &lt;span class="n"&gt;i2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_f7ceebc7cb5d420da69d506ad87316d5-5" name="rest_code_f7ceebc7cb5d420da69d506ad87316d5-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f7ceebc7cb5d420da69d506ad87316d5-5"&gt;&lt;/a&gt;&lt;span class="n"&gt;guard_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="n"&gt;guard_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_f7ceebc7cb5d420da69d506ad87316d5-6" name="rest_code_f7ceebc7cb5d420da69d506ad87316d5-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f7ceebc7cb5d420da69d506ad87316d5-6"&gt;&lt;/a&gt;&lt;span class="hll"&gt;&lt;span class="n"&gt;i3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int_lt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;            &lt;span class="n"&gt;jump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;a id="rest_code_f7ceebc7cb5d420da69d506ad87316d5-7" name="rest_code_f7ceebc7cb5d420da69d506ad87316d5-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f7ceebc7cb5d420da69d506ad87316d5-7"&gt;&lt;/a&gt;&lt;span class="hll"&gt;&lt;span class="n"&gt;guard_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;a id="rest_code_f7ceebc7cb5d420da69d506ad87316d5-8" name="rest_code_f7ceebc7cb5d420da69d506ad87316d5-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f7ceebc7cb5d420da69d506ad87316d5-8"&gt;&lt;/a&gt;&lt;span class="hll"&gt;&lt;span class="n"&gt;jump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the trace represents just one of the paths through the control flow
graph of the original function, which is typical for tracing JITs (the other
paths could incrementally get added later).&lt;/p&gt;
&lt;p&gt;The first guards in both these traces correspond to each other, so the first
chunks to check are the first three operations (lines 1-4). Those operations
don't get changed by the optimizer at all.&lt;/p&gt;
&lt;p&gt;These two identical traces get translated to the following Z3 formulas:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_68fc251bcf284c609d1b29c2b07466ed-1" name="rest_code_68fc251bcf284c609d1b29c2b07466ed-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_68fc251bcf284c609d1b29c2b07466ed-1"&gt;&lt;/a&gt;i1unoptimized == input_i0 + 10
&lt;a id="rest_code_68fc251bcf284c609d1b29c2b07466ed-2" name="rest_code_68fc251bcf284c609d1b29c2b07466ed-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_68fc251bcf284c609d1b29c2b07466ed-2"&gt;&lt;/a&gt;i2unoptimized == If(i1unoptimized &amp;lt; 15, 1, 0)
&lt;a id="rest_code_68fc251bcf284c609d1b29c2b07466ed-3" name="rest_code_68fc251bcf284c609d1b29c2b07466ed-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_68fc251bcf284c609d1b29c2b07466ed-3"&gt;&lt;/a&gt;i1optimized == input_i0 + 10
&lt;a id="rest_code_68fc251bcf284c609d1b29c2b07466ed-4" name="rest_code_68fc251bcf284c609d1b29c2b07466ed-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_68fc251bcf284c609d1b29c2b07466ed-4"&gt;&lt;/a&gt;i2optimized == If(i1optimized &amp;lt; 15, 1, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To check that the two corresponding guards are the same, the solver is asked to
prove that &lt;code class="docutils literal"&gt;(i2unoptimized == 1) == (i2optimized == 1)&lt;/code&gt;. This is
correct, because the formulas for &lt;code class="docutils literal"&gt;i2unoptimized&lt;/code&gt; and &lt;code class="docutils literal"&gt;i2optimized&lt;/code&gt; are
completely identical.&lt;/p&gt;
&lt;p&gt;After checking that the guards behave the same, we add the knowledge to the
solver that the guards passed. So the Z3 formulas become:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-1" name="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-1"&gt;&lt;/a&gt;i1unoptimized == input_i0 + 10
&lt;a id="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-2" name="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-2"&gt;&lt;/a&gt;i2unoptimized == If(i1unoptimized &amp;lt; 15, 1, 0)
&lt;a id="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-3" name="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-3"&gt;&lt;/a&gt;i1optimized == input_i0 + 10
&lt;a id="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-4" name="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-4"&gt;&lt;/a&gt;i2optimized == If(i1optimized &amp;lt; 15, 1, 0)
&lt;a id="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-5" name="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-5"&gt;&lt;/a&gt;i1optimized == 1
&lt;a id="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-6" name="rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_d7d26e4469ec4e5a9fc9e819d98233b3-6"&gt;&lt;/a&gt;i2optimized == 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we continue with the remaining operations of the two traces (lines 6-8).&lt;/p&gt;
&lt;p&gt;We start by adding the &lt;code class="docutils literal"&gt;int_lt&lt;/code&gt; operation in the unoptimized trace to the Z3
formulas:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_c98173f8a2294d9aa2c67d8434da6e24-1" name="rest_code_c98173f8a2294d9aa2c67d8434da6e24-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c98173f8a2294d9aa2c67d8434da6e24-1"&gt;&lt;/a&gt;...
&lt;a id="rest_code_c98173f8a2294d9aa2c67d8434da6e24-2" name="rest_code_c98173f8a2294d9aa2c67d8434da6e24-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_c98173f8a2294d9aa2c67d8434da6e24-2"&gt;&lt;/a&gt;i3unoptimized == If(input_i0 &amp;lt; 6, 1, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because the second guard was optimized away, we need to ask Z3 to prove that
&lt;code class="docutils literal"&gt;i3unoptimized == 1&lt;/code&gt; is always true, which fails and gives the following
counterexample:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_f1f4873d19ab47c08cf25f7554174415-1" name="rest_code_f1f4873d19ab47c08cf25f7554174415-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f1f4873d19ab47c08cf25f7554174415-1"&gt;&lt;/a&gt;input_i0 = 9223372036854775800
&lt;a id="rest_code_f1f4873d19ab47c08cf25f7554174415-2" name="rest_code_f1f4873d19ab47c08cf25f7554174415-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f1f4873d19ab47c08cf25f7554174415-2"&gt;&lt;/a&gt;i1unoptimized = 9223372036854775810
&lt;a id="rest_code_f1f4873d19ab47c08cf25f7554174415-3" name="rest_code_f1f4873d19ab47c08cf25f7554174415-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f1f4873d19ab47c08cf25f7554174415-3"&gt;&lt;/a&gt;i2unoptimized = 0
&lt;a id="rest_code_f1f4873d19ab47c08cf25f7554174415-4" name="rest_code_f1f4873d19ab47c08cf25f7554174415-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f1f4873d19ab47c08cf25f7554174415-4"&gt;&lt;/a&gt;i1optimized = 9223372036854775810
&lt;a id="rest_code_f1f4873d19ab47c08cf25f7554174415-5" name="rest_code_f1f4873d19ab47c08cf25f7554174415-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f1f4873d19ab47c08cf25f7554174415-5"&gt;&lt;/a&gt;i2optimized = 1
&lt;a id="rest_code_f1f4873d19ab47c08cf25f7554174415-6" name="rest_code_f1f4873d19ab47c08cf25f7554174415-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_f1f4873d19ab47c08cf25f7554174415-6"&gt;&lt;/a&gt;i3unoptimized = 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thus demonstrating the bug. The fact that the Z3-based equivalence check also
managed to find the original motivating bug without manually translating it to
a formula is a good confirmation that the approach works.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="second-bug"&gt;
&lt;h2&gt;Second bug&lt;/h2&gt;
&lt;p&gt;So with this code I applied the Z3-based equivalence check to all our optimizer
unit tests. In addition to the bug we've been discussing the whole post, it also
found another buggy test! I had found it too by hand by staring at all the tests
in the process of writing all the Z3 infrastructure, but it was still a good
confirmation that the process worked. This bug was in the range analysis for
&lt;code class="docutils literal"&gt;int_neg&lt;/code&gt;, integer negation. It failed to account that &lt;code class="docutils literal"&gt;&lt;span class="pre"&gt;-MININT&lt;/span&gt; == MININT&lt;/code&gt;
and therefore did a mis-optimization along the following lines:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-1" name="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_efb9db8bdb8d4a74a07f2db484209e8e-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;__pypy__&lt;/span&gt;
&lt;a id="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-2" name="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_efb9db8bdb8d4a74a07f2db484209e8e-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-3" name="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_efb9db8bdb8d4a74a07f2db484209e8e-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-4" name="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_efb9db8bdb8d4a74a07f2db484209e8e-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__pypy__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;intop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-5" name="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_efb9db8bdb8d4a74a07f2db484209e8e-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-6" name="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_efb9db8bdb8d4a74a07f2db484209e8e-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-7" name="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_efb9db8bdb8d4a74a07f2db484209e8e-7"&gt;&lt;/a&gt;            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;a id="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-8" name="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-8" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_efb9db8bdb8d4a74a07f2db484209e8e-8"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;a id="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-9" name="rest_code_efb9db8bdb8d4a74a07f2db484209e8e-9" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_efb9db8bdb8d4a74a07f2db484209e8e-9"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which was wrongly optimized into:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code python"&gt;&lt;a id="rest_code_6676f1cd78a24962825aadbcdce3cf1a-1" name="rest_code_6676f1cd78a24962825aadbcdce3cf1a-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_6676f1cd78a24962825aadbcdce3cf1a-1"&gt;&lt;/a&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;__pypy__&lt;/span&gt;
&lt;a id="rest_code_6676f1cd78a24962825aadbcdce3cf1a-2" name="rest_code_6676f1cd78a24962825aadbcdce3cf1a-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_6676f1cd78a24962825aadbcdce3cf1a-2"&gt;&lt;/a&gt;
&lt;a id="rest_code_6676f1cd78a24962825aadbcdce3cf1a-3" name="rest_code_6676f1cd78a24962825aadbcdce3cf1a-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_6676f1cd78a24962825aadbcdce3cf1a-3"&gt;&lt;/a&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;a id="rest_code_6676f1cd78a24962825aadbcdce3cf1a-4" name="rest_code_6676f1cd78a24962825aadbcdce3cf1a-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_6676f1cd78a24962825aadbcdce3cf1a-4"&gt;&lt;/a&gt;    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__pypy__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;intop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int_sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;a id="rest_code_6676f1cd78a24962825aadbcdce3cf1a-5" name="rest_code_6676f1cd78a24962825aadbcdce3cf1a-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_6676f1cd78a24962825aadbcdce3cf1a-5"&gt;&lt;/a&gt;    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;a id="rest_code_6676f1cd78a24962825aadbcdce3cf1a-6" name="rest_code_6676f1cd78a24962825aadbcdce3cf1a-6" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_6676f1cd78a24962825aadbcdce3cf1a-6"&gt;&lt;/a&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;a id="rest_code_6676f1cd78a24962825aadbcdce3cf1a-7" name="rest_code_6676f1cd78a24962825aadbcdce3cf1a-7" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_6676f1cd78a24962825aadbcdce3cf1a-7"&gt;&lt;/a&gt;    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is wrong precisely for &lt;code class="docutils literal"&gt;x == MININT&lt;/code&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="generating-random-traces"&gt;
&lt;h2&gt;Generating Random Traces&lt;/h2&gt;
&lt;p&gt;These two bugs were the only two that the Z3 checker found for existing unit
tests. To try to find some more bugs I combined PyPy's existing random trace
generator with the Z3 optimization checker. The random trace generator has so
far been mostly used to find bugs in the machine code backends, particularly
also in the register allocator. So far we haven't used it with our optimizer,
but my experiments show that we should have!&lt;/p&gt;
&lt;p&gt;I'm going to describe a little bit how the random trace generator works. It's
actually not that complicated, but there's one neat trick to it.&lt;/p&gt;
&lt;p&gt;The basic idea is straightforward, it starts out with an empty trace with a
random number of input variables. Then it adds some number of operations to the
trace, either regular operations or guards. Every operation takes already
existing variables as input.&lt;/p&gt;
&lt;p&gt;The neat trick is that our random trace generator keeps a concrete random
example value for every one of the input variables, and an example result for
every operation. In this way, it is possible to generate guards that are
consistent with the example values to ensure that running the trace to its end
is possible with at least one set of values.&lt;/p&gt;
&lt;p&gt;Here's an example random trace that is generated, together with the random
example inputs and the results of every operation at the end of every line:&lt;/p&gt;
&lt;pre class="literal-block"&gt;[i0, i1, i2, i3, i4, i5] # example values: 9, 11, -8, -95, 46, 57
i6 = int_add_ovf(i3, i0) # -86
guard_no_overflow()
i7 = int_sub(i2, -35/ci) # 27
i8 = uint_ge(i3, i5) # 1
guard_true(i8)
i9 = int_lt(i7, i8) # 0
i10 = int_mul_ovf(34/ci, i7) # 918
guard_no_overflow()
i11 = int_and(i10, 63/ci) # 22
i12 = int_rshift(i3, i11) # -1
i13 = int_is_zero(i7) # 0
i14 = int_is_true(i13) # 0
guard_false(i13)
i15 = int_lt(i8, i4) # 1
i16 = int_and(i6, i0) # 8
i17 = uint_ge(i6, -6/ci) # 0
finish()&lt;/pre&gt;
&lt;p&gt;Note how every guard generated is true for the example values.&lt;/p&gt;
&lt;p&gt;I have been running this combination of random trace generation and Z3 checking
for many nights and it has found some bugs, which I'll describe in the next
section. It should probably be run for a lot longer, but still a useful
exercise already.&lt;/p&gt;
&lt;p&gt;In this mode, I'm giving every Z3 call a time limit to make sure that the random
tests don't just take arbitrarily long. This means that asking Z3 to prove
something can have three outcomes, either it's proved, or Z3 finds a
counterexample, or Z3 times out.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="bugs-found"&gt;
&lt;h2&gt;Bugs Found&lt;/h2&gt;
&lt;p&gt;In addition to the two bugs I've already described, I'll briefly list the
additional bugs that were found by optimizing random traces and then trying to
prove the equivalence with Z3.&lt;/p&gt;
&lt;p&gt;Most of the bugs were actually identified by optimizing random traces alone, not
by the Z3 component. They manifested as assert failures in the JIT compiler.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The JIT concluded after &lt;code class="docutils literal"&gt;12 == int_mul(x, 12)&lt;/code&gt; that &lt;code class="docutils literal"&gt;x == 1&lt;/code&gt;, which is
incorrect if overflow occurred (a counterexample is &lt;code class="docutils literal"&gt;0x8000000000000001&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;An amusing bug, where from &lt;code class="docutils literal"&gt;0 == int_lshift(0x1000000000000000, x)&lt;/code&gt; with
&lt;code class="docutils literal"&gt;x &amp;lt;= 0 &amp;lt;= 15&lt;/code&gt;, the JIT concluded that &lt;code class="docutils literal"&gt;0x1000000000000000 == 0&lt;/code&gt;,
triggering an assert. This wrong conclusion was again caused by not taking the
possibility of overflow into account.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A corner case in an optimization for chained integer additions with a
constant, where in complex enough expressions, the wrong IR API was used
(which works correctly in simple cases). Again, this triggered an assert.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This shows that we should have been fuzzing our JIT optimizer already (not a
surprising  observation in hindsight, fuzz all the things!).&lt;/p&gt;
&lt;p&gt;Thankfully, there was also one further bug that really failed in the Z3
verifier. It's a bug in common subexpression elimination / arithmetic
simplification, which again does not take overflow correctly into account.&lt;/p&gt;
&lt;p&gt;The buggy trace looks like this (unfortunately it's not easily possible to show
this bug in Python code).&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_3620eaf10f5b428db60041e562fb620e-1" name="rest_code_3620eaf10f5b428db60041e562fb620e-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3620eaf10f5b428db60041e562fb620e-1"&gt;&lt;/a&gt;[a, b]
&lt;a id="rest_code_3620eaf10f5b428db60041e562fb620e-2" name="rest_code_3620eaf10f5b428db60041e562fb620e-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3620eaf10f5b428db60041e562fb620e-2"&gt;&lt;/a&gt;c = int_add(a, b)
&lt;a id="rest_code_3620eaf10f5b428db60041e562fb620e-3" name="rest_code_3620eaf10f5b428db60041e562fb620e-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3620eaf10f5b428db60041e562fb620e-3"&gt;&lt;/a&gt;r = int_sub_ovf(c, b)
&lt;a id="rest_code_3620eaf10f5b428db60041e562fb620e-4" name="rest_code_3620eaf10f5b428db60041e562fb620e-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3620eaf10f5b428db60041e562fb620e-4"&gt;&lt;/a&gt;guard_no_ovf()
&lt;a id="rest_code_3620eaf10f5b428db60041e562fb620e-5" name="rest_code_3620eaf10f5b428db60041e562fb620e-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_3620eaf10f5b428db60041e562fb620e-5"&gt;&lt;/a&gt;finish(r)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This was optimized to:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_7b6bd78b8f4a460290aa41e72ed82516-1" name="rest_code_7b6bd78b8f4a460290aa41e72ed82516-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_7b6bd78b8f4a460290aa41e72ed82516-1"&gt;&lt;/a&gt;[a, b]
&lt;a id="rest_code_7b6bd78b8f4a460290aa41e72ed82516-2" name="rest_code_7b6bd78b8f4a460290aa41e72ed82516-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_7b6bd78b8f4a460290aa41e72ed82516-2"&gt;&lt;/a&gt;finish(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which is incorrect, because the guard can fail given the right inputs.
But the optimizer concluded that the subtraction is safe, because its the
inverse of an earlier addition, not taking into account that this earlier
addition can have overflowed.&lt;/p&gt;
&lt;p&gt;Note that a related optimization is actually correct. Given this code:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_7263321dcdfc44018cd7bb45f56f2564-1" name="rest_code_7263321dcdfc44018cd7bb45f56f2564-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_7263321dcdfc44018cd7bb45f56f2564-1"&gt;&lt;/a&gt;[a, b]
&lt;a id="rest_code_7263321dcdfc44018cd7bb45f56f2564-2" name="rest_code_7263321dcdfc44018cd7bb45f56f2564-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_7263321dcdfc44018cd7bb45f56f2564-2"&gt;&lt;/a&gt;c = int_add_ovf(a, b)
&lt;a id="rest_code_7263321dcdfc44018cd7bb45f56f2564-3" name="rest_code_7263321dcdfc44018cd7bb45f56f2564-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_7263321dcdfc44018cd7bb45f56f2564-3"&gt;&lt;/a&gt;guard_no_ovf()
&lt;a id="rest_code_7263321dcdfc44018cd7bb45f56f2564-4" name="rest_code_7263321dcdfc44018cd7bb45f56f2564-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_7263321dcdfc44018cd7bb45f56f2564-4"&gt;&lt;/a&gt;r = int_sub(c, b)
&lt;a id="rest_code_7263321dcdfc44018cd7bb45f56f2564-5" name="rest_code_7263321dcdfc44018cd7bb45f56f2564-5" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_7263321dcdfc44018cd7bb45f56f2564-5"&gt;&lt;/a&gt;finish(r)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It can be optimized to:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code text"&gt;&lt;a id="rest_code_cca5e8e743e74f478db63b195d624805-1" name="rest_code_cca5e8e743e74f478db63b195d624805-1" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_cca5e8e743e74f478db63b195d624805-1"&gt;&lt;/a&gt;[a, b]
&lt;a id="rest_code_cca5e8e743e74f478db63b195d624805-2" name="rest_code_cca5e8e743e74f478db63b195d624805-2" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_cca5e8e743e74f478db63b195d624805-2"&gt;&lt;/a&gt;c = int_add_ovf(a, b)
&lt;a id="rest_code_cca5e8e743e74f478db63b195d624805-3" name="rest_code_cca5e8e743e74f478db63b195d624805-3" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_cca5e8e743e74f478db63b195d624805-3"&gt;&lt;/a&gt;guard_no_ovf()
&lt;a id="rest_code_cca5e8e743e74f478db63b195d624805-4" name="rest_code_cca5e8e743e74f478db63b195d624805-4" href="https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html#rest_code_cca5e8e743e74f478db63b195d624805-4"&gt;&lt;/a&gt;finish(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id="future-work-and-conclusion"&gt;
&lt;h2&gt;Future Work and Conclusion&lt;/h2&gt;
&lt;p&gt;In the current form the Z3 checker is only a start, even though it has already
been concretely useful. There are various directions into which we could extend
it. In addition to generate random tests completely from scratch, we could also
start from the existing manually written unit-tests and randomly mutate those.&lt;/p&gt;
&lt;p&gt;I also want to extend the Z3 checker with support more operations, heap
operations in particular (but it's not quite clear to me how to model garbage
collection).&lt;/p&gt;
&lt;p&gt;I also want to try to switch the code away from the Z3 API and use the more
general &lt;a class="reference external" href="https://smtlib.cs.uiowa.edu/"&gt;smtlib&lt;/a&gt; interface directly, in order to be able to use other SMT
checkers than Z3, eg &lt;a class="reference external" href="https://cvc4.github.io/"&gt;CVC4&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But all in all this was a fun and not too hard way to find a bunch of bugs in
our optimizer! And the infrastructure is now in place, which means that we run
some random test cases every time we execute our tests. This is going to be
particularly useful when we do further work on the integer reasoning of the JIT
(like Nico is doing, for example). As of time of writing of this post, all the
bugs mentioned have been fixed and the Z3 code has landed on the default branch
and runs as part of PyPy's CI infrastructure.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="acknowledgements"&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to &lt;a class="reference external" href="http://saambarati.org/"&gt;Saam Barati&lt;/a&gt;, &lt;a class="reference external" href="https://bernsteinbear.com"&gt;Max Bernstein&lt;/a&gt;, &lt;a class="reference external" href="https://www.cs.hhu.de/lehrstuehle-und-arbeitsgruppen/softwaretechnik-und-programmiersprachen/unser-team/team/schmidt"&gt;Joshua Schmidt&lt;/a&gt; and &lt;a class="reference external" href="https://martinfriedrichberger.net/"&gt;Martin
Berger&lt;/a&gt;, for great feedback on drafts of this post!&lt;/p&gt;
&lt;/section&gt;</description><category>jit</category><category>testing</category><guid>https://www.pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html</guid><pubDate>Sun, 11 Dec 2022 18:00:00 GMT</pubDate></item></channel></rss>